<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gun Game - Full Enhanced Version</title>
<style>
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: radial-gradient(circle at center, #222 0%, #000 80%);
    color: white;
    overflow: hidden;
  }
  #gameCanvas {
    display: none;
    background: transparent;
  }
  #charSelect {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    flex-direction: column;
    gap: 15px;
  }
  .charCard {
    border: 2px solid white;
    padding: 20px;
    width: 220px;
    text-align: center;
    cursor: pointer;
    border-radius: 8px;
    background: #111;
    transition: background 0.3s, transform 0.3s;
    user-select: none;
  }
  .charCard:hover {
    background: #333;
    transform: scale(1.05);
  }
  #ui {
    position: fixed;
    top: 12px;
    left: 12px;
    font-weight: 600;
    user-select: none;
    z-index: 10;
  }
  #score {
    font-size: 22px;
    margin-bottom: 8px;
  }
  #healthBarContainer {
    width: 250px;
    height: 24px;
    background: #444;
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 8px;
  }
  #healthBar {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #f44336, #b71c1c);
    transition: width 0.3s ease-out;
  }
  #wave {
    font-size: 20px;
  }
  #upgradeOverlay button {
    background: #222;
    color: white;
    border: 2px solid white;
    padding: 14px 28px;
    margin: 14px;
    font-size: 20px;
    font-weight: 600;
    cursor: pointer;
    border-radius: 6px;
    transition: background 0.25s, transform 0.2s;
  }
  #upgradeOverlay button:hover {
    background: #555;
    transform: scale(1.05);
  }
</style>
</head>
<body>
<div id="charSelect">
  <h1>Select Your Character</h1>
  <div class="charCard" onclick="startGame('Soldier')">
    <h2>Soldier</h2>
    <p>Health: 100</p>
    <p>Speed: 5</p>
    <p>Fire Rate: Medium</p>
  </div>
  <div class="charCard" onclick="startGame('Scout')">
    <h2>Scout</h2>
    <p>Health: 70</p>
    <p>Speed: 7</p>
    <p>Fire Rate: Fast</p>
  </div>
  <div class="charCard" onclick="startGame('Tank')">
    <h2>Tank</h2>
    <p>Health: 150</p>
    <p>Speed: 3</p>
    <p>Fire Rate: Slow</p>
  </div>
</div>

<div id="ui" style="display:none;">
  <div id="score">Score: 0</div>
  <div id="healthBarContainer"><div id="healthBar"></div></div>
  <div id="wave">Wave: 1</div>
</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = {}, keys = {}, bullets = [], enemies = [], score = 0, wave = 1;
let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
let canShoot = true,
  fireRate = 400,
  damage = 1,
  ammoSpread = 1,
  upgradePending = false,
  bossActive = false,
  bossAttackCooldown = 0;

const characters = {
  Soldier: { health: 100, speed: 5, fireRate: 400 },
  Scout: { health: 70, speed: 7, fireRate: 200 },
  Tank: { health: 150, speed: 3, fireRate: 700 },
};

const upgrades = [
  { name: "ðŸ’¥ Damage Up", apply: () => damage++ },
  {
    name: "âš¡ Fire Rate Up",
    apply: () => {
      fireRate = Math.max(100, fireRate - 50);
    },
  },
  {
    name: "ðŸ“¦ Spread Shot",
    apply: () => {
      ammoSpread = Math.min(3, ammoSpread + 1);
    },
  },
];

// Sounds with multiple variants for gunshots
const shootSounds = [
  new Audio("https://cdn.pixabay.com/download/audio/2022/03/15/audio_8770a2d12c.mp3?filename=gunshot-108577.mp3"),
  new Audio("https://cdn.pixabay.com/download/audio/2021/08/04/audio_eb3296d938.mp3?filename=gunshot-21269.mp3"),
  new Audio("https://cdn.pixabay.com/download/audio/2022/04/14/audio_48135ddcfc.mp3?filename=gun-shot-6754.mp3")
];

const bossAttackSound = new Audio("https://cdn.pixabay.com/download/audio/2021/08/04/audio_841462663e.mp3?filename=laser-attack-13675.mp3");
const bossDeathSound = new Audio("https://cdn.pixabay.com/download/audio/2022/05/09/audio_5dd8ae2d1d.mp3?filename=explosion-53556.mp3");
const playerDeathSound = new Audio("https://cdn.pixabay.com/download/audio/2021/08/04/audio_2c76ed6e82.mp3?filename=game-over-2016-94502.mp3");

let muzzleFlash = {active: false, timer: 0, maxTime: 5};

function startGame(character) {
  document.getElementById("charSelect").style.display = "none";
  document.getElementById("ui").style.display = "block";
  canvas.style.display = "block";

  const charStats = characters[character];
  player = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    size: 20,
    health: charStats.health,
    maxHealth: charStats.health,
    speed: charStats.speed,
  };
  fireRate = charStats.fireRate;
  damage = 1;
  ammoSpread = 1;
  score = 0;
  wave = 1;
  upgradePending = false;
  bossActive = false;
  bossAttackCooldown = 0;
  enemies = [];

  spawnEnemies(wave * 3);
  loop();
}

window.addEventListener("keydown", (e) => (keys[e.key.toLowerCase()] = true));
window.addEventListener("keyup", (e) => (keys[e.key.toLowerCase()] = false));
window.addEventListener("mousemove", (e) => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});
window.addEventListener("click", () => {
  if (!upgradePending && canShoot) {
    shoot();
    canShoot = false;
    setTimeout(() => (canShoot = true), fireRate);
  }
});

function playShootSound() {
  const snd = shootSounds[Math.floor(Math.random() * shootSounds.length)];
  snd.currentTime = 0;
  snd.play();
}

function shoot() {
  const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  muzzleFlash.active = true;
  muzzleFlash.timer = muzzleFlash.maxTime;
  for (let i = 0; i < ammoSpread; i++) {
    let spread = (i - (ammoSpread - 1) / 2) * 0.15;
    bullets.push({
      x: player.x + Math.cos(angle) * player.size,
      y: player.y + Math.sin(angle) * player.size,
      dx: Math.cos(angle + spread) * 15,
      dy: Math.sin(angle + spread) * 15,
      size: 5,
    });
  }
  playShootSound();
}

function spawnEnemies(count) {
  enemies = [];
  bossActive = false;
  for (let i = 0; i < count; i++) {
    let side = Math.random() < 0.5 ? 0 : 1;
    let x = side === 0 ? -30 : canvas.width + 30;
    let y = Math.random() * canvas.height;
    enemies.push({
      x,
      y,
      size: 25 + wave * 2,
      speed: 1 + wave * 0.2,
      health: 2 + wave,
      maxHealth: 2 + wave,
      isBoss: false,
    });
  }
}

function spawnBoss() {
  bossActive = true;
  enemies = [
    {
      x: canvas.width / 2,
      y: 150,
      size: 80,
      speed: 2,
      health: 20 + wave * 10,
      maxHealth: 20 + wave * 10,
      isBoss: true,
      direction: 1,
      attackTimer: 0,
      attackInterval: 120,
      dying: false,
      deathTimer: 0,
    },
  ];
}

function drawPlayer() {
  ctx.save();
  ctx.translate(player.x, player.y);
  const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
  ctx.rotate(angle);

  // Player body
  ctx.fillStyle = "lime";
  ctx.shadowColor = "lime";
  ctx.shadowBlur = 8;
  ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size);

  // Gun barrel
  ctx.fillStyle = "orange";
  ctx.fillRect(player.size / 2, -6, 26, 12);

  // Muzzle flash
  if (muzzleFlash.active) {
    ctx.fillStyle = "yellow";
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.moveTo(player.size / 2 + 26, 0);
    ctx.lineTo(player.size / 2 + 26 + 20, 8);
    ctx.lineTo(player.size / 2 + 26 + 20, -8);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function update() {
  if (upgradePending) return;

  if (keys["w"]) player.y -= player.speed;
  if (keys["s"]) player.y += player.speed;
  if (keys["a"]) player.x -= player.speed;
  if (keys["d"]) player.x += player.speed;

  // Bound player
  player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
  player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));

  if (muzzleFlash.active) {
    muzzleFlash.timer--;
    if (muzzleFlash.timer <= 0) muzzleFlash.active = false;
  }

  bullets.forEach((b, i) => {
    b.x += b.dx;
    b.y += b.dy;
    if (b.x < -10 || b.y < -10 || b.x > canvas.width + 10 || b.y > canvas.height + 10) bullets.splice(i, 1);
  });

  enemies.forEach((e, i) => {
    if (e.isBoss) {
      bossBehavior(e, i);
    } else {
      let dx = player.x - e.x;
      let dy = player.y - e.y;
      let dist = Math.hypot(dx, dy);
      e.x += (dx / dist) * e.speed;
      e.y += (dy / dist) * e.speed;
    }

    let distPlayer = Math.hypot(e.x - player.x, e.y - player.y);
    if (distPlayer < player.size + e.size) {
      if (!e.isBoss || (e.isBoss && !e.dying)) {
        player.health -= e.isBoss ? 40 : 10;
        enemies.splice(i, 1);
        if (player.health <= 0) {
          triggerPlayerDeath();
        }
      }
    }
  });

  bullets.forEach((b, bi) => {
    enemies.forEach((e, ei) => {
      let dist = Math.hypot(b.x - e.x, b.y - e.y);
      if (dist < b.size + e.size && !e.dying) {
        e.health -= damage;
        bullets.splice(bi, 1);
        if (e.health <= 0) {
          if (e.isBoss) {
            e.dying = true;
            e.deathTimer = 30;
            bossDeathSound.play();
            score += 50 * wave;
          } else {
            enemies.splice(ei, 1);
            score += 10 * wave;
          }
        }
      }
    });
  });

  // Remove dead bosses after death animation
  enemies = enemies.filter((e) => !(e.isBoss && e.dying && e.deathTimer <= 0));

  if (bossActive && enemies.length === 0) {
    upgradePending = true;
    showUpgradeMenu();
  } else if (!bossActive && enemies.length === 0) {
    wave++;
    if (wave % 5 === 0) {
      spawnBoss();
    } else {
      spawnEnemies(wave * 3);
    }
  }

  // Update UI
  document.getElementById("score").textContent = "Score: " + score;
  document.getElementById("wave").textContent = "Wave: " + wave;

  // Health bar update
  const healthPercent = Math.max(0, (player.health / player.maxHealth) * 100);
  document.getElementById("healthBar").style.width = healthPercent + "%";
}

function bossBehavior(boss, index) {
  if (boss.dying) {
    boss.deathTimer--;
    // Animate boss fading out
    boss.size -= 2;
    if (boss.size <= 0) enemies.splice(index, 1);
    return;
  }
  boss.x += boss.speed * boss.direction;
  if (boss.x > canvas.width - boss.size / 2) boss.direction = -1;
  if (boss.x < boss.size / 2) boss.direction = 1;

  if (bossAttackCooldown <= 0) {
    bossAttackCooldown = boss.attackInterval;
    bossAttack(boss);
  } else {
    bossAttackCooldown--;
  }
}

function bossAttack(boss) {
  bossAttackSound.currentTime = 0;
  bossAttackSound.play();

  // Laser line attack (thick red horizontal line)
  ctx.save();
  ctx.strokeStyle = "rgba(255,0,0,0.7)";
  ctx.lineWidth = 10;
  ctx.beginPath();
  ctx.moveTo(0, boss.y);
  ctx.lineTo(canvas.width, boss.y);
  ctx.stroke();
  ctx.restore();

  // Damage player if in laser line +/- 40px
  if (player.y > boss.y - 40 && player.y < boss.y + 40) {
    player.health -= 25;
    if (player.health <= 0) {
      triggerPlayerDeath();
    }
  }
}

function triggerPlayerDeath() {
  playerDeathSound.play();
  upgradePending = true;
  alert("Game Over! Final Score: " + score);
  location.reload();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background subtle stars for atmosphere
  drawBackground();

  // Draw bullets with glow
  bullets.forEach((b) => {
    ctx.beginPath();
    ctx.fillStyle = "yellow";
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 15;
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  });

  // Draw enemies
  enemies.forEach((e) => {
    ctx.save();
    ctx.beginPath();
    if (e.isBoss) {
      ctx.fillStyle = e.dying ? `rgba(255,0,0,${e.size / 80})` : "red";
    } else {
      ctx.fillStyle = "white";
    }
    ctx.shadowColor = e.isBoss ? "red" : "white";
    ctx.shadowBlur = 8;
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();

    // Boss health bar
    if (e.isBoss && !e.dying) {
      ctx.fillStyle = "black";
      ctx.fillRect(e.x - 50, e.y - e.size - 25, 100, 12);
      ctx.fillStyle = "lime";
      ctx.fillRect(e.x - 50, e.y - e.size - 25, (e.health / e.maxHealth) * 100, 12);
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.strokeRect(e.x - 50, e.y - e.size - 25, 100, 12);
    }
    ctx.restore();
  });

  drawPlayer();
}

function drawBackground() {
  // subtle twinkling stars effect
  for (let i = 0; i < 80; i++) {
    const x = (i * 123 + (Date.now() / 20)) % canvas.width;
    const y = ((i * 45 + Date.now() / 30) % canvas.height);
    const size = 0.7 + Math.sin(Date.now() / 500 + i) * 0.5;
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,0.2)";
    ctx.shadowBlur = 0;
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function loop() {
  update();
  draw();
  if (!upgradePending) requestAnimationFrame(loop);
}

function showUpgradeMenu() {
  const overlay = document.createElement("div");
  overlay.id = "upgradeOverlay";
  overlay.style.position = "fixed";
  overlay.style.top = 0;
  overlay.style.left = 0;
  overlay.style.width = "100vw";
  overlay.style.height = "100vh";
  overlay.style.backgroundColor = "rgba(0,0,0,0.95)";
  overlay.style.display = "flex";
  overlay.style.flexDirection = "column";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  overlay.style.zIndex = "1000";

  const title = document.createElement("h2");
  title.textContent = "Choose Your Upgrade";
  overlay.appendChild(title);

  upgrades.forEach((upg) => {
    const btn = document.createElement("button");
    btn.textContent = upg.name;
    btn.onclick = () => {
      upg.apply();
      upgradePending = false;
      document.body.removeChild(overlay);
      wave++;
      if (wave % 5 === 0) {
        spawnBoss();
      } else {
        spawnEnemies(wave * 3);
      }
      loop();
    };
    overlay.appendChild(btn);
  });

  document.body.appendChild(overlay);
}
</script>
</body>
</html>
